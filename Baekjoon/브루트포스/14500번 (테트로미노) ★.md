---
created: 2025-01-18 17:20
title: 14500번 (테트로미노)
number: 14500
category:
  - 브루트포스
  - DFS
source-url:
  - https://www.acmicpc.net/problem/14500
acc-rate: 36%
solved: false
noteCompleted: true
tags:
  - "#algorithm-problem"
  - baekjoon
last_modified: 2025-01-18T19:23:00
---
## 💁 내 풀이 (X)
#### 🍪 설명
> 1x1 블록 4개를 이어 붙인 테트로미노가 배치된 칸의 합이 가장 큰 경우를 찾아야 한다.

- 문제를 보자마자 DFS로 해결할 수 있겠다고 생각했다.
	- 하지만 DFS 구현에 익숙하지 않아서 코드를 작성하지 못했다.

> DFS, BFS 등 그래프 알고리즘, 재귀를 많이 공부 해야겠다.
---
## 💡 정답 코드 및 설명
#### 🍪 설명 ([참고 사이트](https://velog.io/@thsamajiki/%EB%B0%B1%EC%A4%80-14500.-%ED%85%8C%ED%8A%B8%EB%A1%9C%EB%AF%B8%EB%85%B8-%EC%9E%90%EB%B0%94-JAVA))
- `ㅏ`, `ㅓ`, `ㅜ`, `ㅗ` 모양의 처리
	- `ㅏ` 모양을 만든다고 가정하면
		- 첫 번째 칸에서 두 번째 칸으로 이동한 후, 세 번째 칸은 "가로"로 이동하고 네 번째 칸은 다시 "세로"로 돌아와야 한다.
		- 단순히 상하좌우로 탐색만 하면 `ㅏ` 모양을 만들 수 없고, 원래 위치로 돌아가서 그 후에 다시 다른 칸을 탐색해야 한다.

###### 코드 (616 ms)
```java
public class B14500 {

	// 각각 상, 하, 좌, 우를 나타낸다. 두 배열은 함께 사용된다.
    static int dr[] = {-1, 1, 0, 0}; 
    static int dc[] = {0, 0, -1, 1};
	
    static int[][] board; // 보드
    static boolean[][] isVisited; // 방문 여부
    static int max; // 최대합

    static int maxRow; // 보드의 행
    static int maxCol; // 보드의 열

    public static void main(String[] args) throws IOException {
        sol1();
    }

    public static void sol1() throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
	    
	    // 초기화 작업
        maxRow = Integer.parseInt(st.nextToken()); // 보드 행 수 초기화
        maxCol = Integer.parseInt(st.nextToken()); // 보드 열 수 초기화
        board = new int[maxRow][maxCol]; // 보드 생성
        isVisited = new boolean[maxRow][maxCol];  // 방문 여부 배열 초기화
        max = 0; // 최대 합은 0으로 초기화
		
		// 보드의 수를 입력받아 저장
        for (int i = 0; i < maxRow; i++) {
            st = new StringTokenizer(br.readLine(), " ");
            for (int j = 0; j < maxCol; j++) {
                board[i][j] = Integer.parseInt(st.nextToken());
            }
        }
		
		// 📌 알고리즘 수행: 각 칸마다 DFS 메서드를 호출
        for (int i = 0; i < maxRow; i++) {
            for (int j = 0; j < maxCol; j++) {
                isVisited[i][j] = true; // 시작 칸의 isVisted를 true로 변경
                dfs(i, j, board[i][j], 1);
                isVisited[i][j] = false; // 탐색이 끝나면 시작 칸의 isVisited를 false로 되돌림
            }
        }
        System.out.println(max);
    }
    
	// 📌 DFS 메서드
    private static void dfs(int row, int col, int sum, int count) {
        // 종료 조건
        if (count == 4) {
            max = Math.max(max, sum);
            return;
        }

        // 탐색: 깊이 우선 탐색을 통한 4개의 칸을 이어붙여 합을 구한다.
        for (int i = 0; i < 4; i++) { 
	        // 상하좌우로 이동할 수 있는 방향 탐색
            int newRow = row + dr[i];
            int newCol = col + dc[i];
			
			// newRow와 newCol을 계산하고, 해당 위치가 배열내의 범위인지, 이미 방문했는지 확인
            if (newRow < 0 || newCol < 0 || newRow >= maxRow || newCol >= maxCol || isVisited[newRow][newCol]) {
                continue;
            }
			
			// 방문되지 않았다면  방문 -> 방문 여부를 true로 변경
            isVisited[newRow][newCol] = true;

			// count가 2일 때 -> "ㅏ", "ㅓ", "ㅜ", "ㅗ" 모양을 처리하기 위해 현재 위치로 다시 탐색
            if (count == 2) { 
                dfs(row, col, sum + board[newRow][newCol], count + 1); // 현재 위치로 다시 탐색
            }
			
			// 일반적인 경우 - 상하좌우로 이동하며 DFS 진행
            dfs(newRow, newCol, sum + board[newRow][newCol], count + 1); // 새로운 위치로 탐색
			
			// 탐색이 끝나면 방문 표시를 제거
            isVisited[newRow][newCol] = false; 
        }
    }
}
```
#### 🍪 시간 복잡도 및 공간 복잡도
###### 시간 복잡도
- 각 칸마다 DFS 호출 (O(NxM))
	- 각 DFS 호출마다 최대 4번 방향 탐색
		- 각 방향에 대해 탐색할 때마다 재귀가 깊이 4까지 진행 (첫칸 제외 3칸 더 선택)
			- count가 2일 경우 두번의 재귀 호출 발생 (현재위치 탐색 + 일반 탐색)

- 따라서 O(NxM)

---
## 📝 메모 
- DFS, BFS 알고리즘을 연습을 많이 할 필요가 있다.






